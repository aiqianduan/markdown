> 数据库管理系统（DBMS）中的并发控制的任务是确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性。

#### 数据库锁
- 悲观锁(悲观并发控制):假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作
- 乐观锁(乐观并发控制):假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性

###### 悲观锁(pcc)
> 悲观并发控制主要用于数据争用激烈的环境，以及发生并发冲突时使用锁保护数据的成本要低于回滚事务的成本的环境中。
- Mysql InnoDb使用悲观锁
> 需要关闭自动提交 set autocommit = 0;
```
## 开启事务
begin; | begin work; | start transaction;
select * from info_salary where sal_id = 1 for update;
select * from test where sal_id = 2;
commit;
```
<font color="red">*for update*</font>通过开启排他锁的方式实现悲观锁，其它的事务必须等本次事务提交之后才能执行
> mysql Innodb默认行级锁。行级锁都是基于索引的，<font color="red">如果一条SQL语句用不到索引是不会使用行级锁的，会使用表级锁把整张表锁住</font>

###### 乐观锁(occ)
> 假设多用户并发的事务在处理时不会彼此互相影响，各事务能够在不产生锁的情况下处理各自影响的那部分数据。在提交数据更新之前，每个事务会先检查在该事务读取数据后，有没有其他事务又修改了该数据。如果其他事务有更新的话，正在提交的事务会进行回滚

> 相对悲观锁而言，乐观锁假设认为数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则让返回用户错误的信息，让用户决定如何去做

>在对数据库进行处理的时候，乐观锁并不会使用数据库提供的锁机制。一般的实现乐观锁的方式就是<font color="red">记录数据版本</font>

- 数据版本
为数据增加的一个版本标识。当读取数据时，将版本标识的值一同读出，数据每更新一次，同时对版本标识进行更新。当我们提交更新的时候，判断数据库表对应记录的当前版本信息与第一次取出来的版本标识进行比对，如果数据库表当前版本号与第一次取出来的版本标识值相等，则予以更新，否则认为是过期数据。

- 数据版本实现方式
>>> 1.使用版本号
```
update t_goods
set status = 1,version = version+ 1
where id=1 and version = 0;
## 表结构
mysql> select * from t_goods;  
+----+--------+------+---------+  
| id | status | name | version |  
+----+--------+------+---------+  
|  1 |      1 | 道具 |       1 |  
|  2 |      2 | 装备 |       2 |  
```
>>> 2.使用时间戳

